Hello, today I'd like to talk about the Jenkins and GitLab integrated toolset. While GitLab does provide its own CI-CD functionality, there are a variety of reasons why a customer might use Jenkins integrated with GitLab instead of just using GitLab CI. Sometimes those customers have complex legacy build jobs that need some work in order to rewrite them to GitLab jobs instead. In other cases, some teams are really comfortable with Jenkins CI and are not quite ready or able to make a shift, but they want to take advantage of as much GitLab functionality as possible in terms of source code management and merge requests. And then we have organizations where some teams have decided to use Jenkins while other teams have decided to use GitLab for CI-CD. And in this case, we want to be able to support consistent CI-CD analytics reporting across all teams. It would be really awkward to have some reporting come out of Jenkins and other reporting come out of GitLab, so the integration allows us to see some metrics for all teams right within GitLab. Now with the GitLab integration, there's a couple of different options. Many people who are accustomed to using Jenkins out of the box with source code management of an SCM system tend to think about the basic Git-Jenkins integration, where you can point Jenkins to your source code repository in Git, and then Jenkins will periodically build that source code based on a polling system. That's great, but it doesn't give developers feedback in real time or as quickly as sometimes they would like. We want to make sure that developers are getting fast feedback, and one way to do that is to use the GitLab webhook that can trigger a Jenkins job or pipeline when an event happens in CI, such as a push or merge request change. With the standard webhook, though, no results are seen in GitLab. So the GitLab Jenkins integration actually provides the ability to use a webhook to trigger those builds, but then also gives us the ability to see the results of those Jenkins builds or pipelines directly within GitLab. That's going to allow GitLab users to see their pipelines directly in GitLab, use other functionalities such as merge requests with pipelines must succeed enabled to make sure that all of their code is clean and well tested and reviewed prior to getting merged into the main line, the master or whatever protected branch they're using. And it's also going to allow them to not have to switch between tools as long as their pipelines in Jenkins are running successfully. They'll see the successful status in GitLab and they won't have to go look for a status in Jenkins. Of course, then we're also being able to now gather all of the executed pipeline data, whether it's from a GitLab pipeline for those teams using GitLab for CI or Jenkins pipeline for those teams using Jenkins for CI. And we're going to be able to have consistent metrics across our team so we can understand how we're doing from a CI CD perspective, looking at metrics in a single tool. In order to set up the integration, there are some things that need to be done on both the Jenkins side and the GitLab side. So first on the Jenkins side, we need to make sure that the Git plugin is installed as well as the GitLab plugin. There are also GitLab settings that need to be configured in the main area where you manage Jenkins. And then you have to configure your Jenkins project to use the appropriate GitLab connection that you've configured as well as the GitLab information for the project. And you have to specify that you want to trigger a build when a change is pushed to GitLab. Now depending on which types of jobs you're defining in Jenkins, you might also have a post action to publish build status to GitLab that should be configured for your job. If you're using a pipeline job, you will have to add steps in your pipeline to update the GitLab commit status via your Jenkins file instead. On the GitLab side, it's a project level integration as part of the project integration menu. We need to, in that Jenkins CI integration, configure the Jenkins URL, the project, and the username and password or API token that will be used. If we're using a Jenkins pipeline and we want to store the Jenkins file in our source code repo, we also need to add the Jenkins file into the root of our source code repo as well. Now here's the overall flow. So first of all, developer is going to do something and then push those changes to GitLab. To do something typically means make changes to the source code and commit them. It could be tagging the repository. It could also mean creating or updating a merge request, which really means making changes to a branch associated to that merge request. Once those things are pushed to the GitLab repo, then the webhook is going to trigger and send that payload information about what just happened to Jenkins. Builds will then execute whatever job has been configured to execute based on that trigger. And then the commit status will be sent back to GitLab. So what was the result of that build or the particular pipeline stage? Once that has run, we will be able to see those build stage results as job results in our pipeline, and those pipeline results, as always, will also be displayed as part of any applicable merge request. So that's going to allow us to use all of that great functionality that's innately part of a merge request in GitLab, but still have the pipeline being executed in Jenkins instead of GitLab. There's two different configurations that we need to think about. They work slightly differently, so I'm calling them both out. First of all, in Jenkins, you can have a freestyle job. And with that, you simply point to the appropriate GitLab repository, and then you set up a post build action to report back whether that job passed or failed. So you will see that job as a pipeline in GitLab as an external Jenkins job, and you'll see the success or failure that has been reported. If you're using a pipeline job in Jenkins instead, whether you're storing your pipeline Jenkins file directly on the Jenkins server or in a Git repository, there are some additional steps you have to add to that pipeline file itself. There is no post build action in Jenkins in this case. Instead, we have a lot more flexibility and a lot more power with Jenkins pipelines, because for each stage that we're executing in Jenkins, we can have one or more GitLab jobs that we're reporting on based on that stage. And we do that via this update GitLab commit status that will then report back the status based on whatever name we give it, and we'll report whatever state we specify and pass in there. So that's going to help us a lot. So just keep in mind that it's right here, the build, the name build, and the state of pending in our particular case. Yeah, that's going to happen. And we can have as many of these different status updates as we want to. So in a lot of cases, first of all, we can have a status update back to GitLab for each stage that we're executing in Jenkins, or even multiple different statuses with multiple different names within the same stage in Jenkins. So that's powerful. If you have these really long, complex build scripts, you are now going to be able to break it up into what looks like different subsets of jobs when it's reported on the GitLab side. So you can start to see where things passed or failed in Jenkins based on how you break that up. But at least for each stage that you define in Jenkins, you want to have a GitLab commit status being updated. And we actually want to execute various different updates, typically one at the beginning of the stage, as we are getting ready to do whatever steps are defined in that stage. We would want to set our build to pending, or a job to pending. And then once we get the stage successfully executed, or for some reason the stage fails, we would want to add a separate set of GitLab update GitLab commit statuses for that same name. To reflect that success or that failure. And I'll show you a case where we have a couple of different jobs defined, one for each stage of our GitLab pipeline, or sorry, of our Jenkins pipeline that's getting reported back to GitLab. So let's go ahead and see it in action. I have a couple of these cases set up, and we can jump over, first of all, and look at a freestyle job that's set up in Jenkins. So here's our Jenkins freestyle job. If we look at it in terms of how it's configured, we'll see that we have selected GitHub project, ignore the label GitHub, we just reuse the GitHub label, that's what it is. We point it to our GitLab project URL, and we use the GitLab connection, this is what we've set up as part of Manage Jenkins when we're setting up the plugin. It allows us to, you know, connect to the appropriate GitLab instance. In terms of source code management, then we'll specify Git, and again, the URL to the appropriate project where that Git repo exists in the credentials we're going to use, and we're going to specify build when the change is pushed to GitLab. Usually, we keep all these triggers exactly how they are by default, but you do have options here in terms of which triggers will cause a build on the Jenkins side. As a post build action, we want to turn on this update or publish or build status to GitLab. That is going to allow us to make sure that we have the status reflected back in our project Now, on the GitLab side, let's just go back to the job itself, but on the GitLab side, what we're going to want to do is to set up a GitLab project, and in the integrations for that GitLab project, we can see that we have a project that is And in the integrations for that GitLab project, we can see that we've already configured our Jenkins integration, so here we can see with Jenkins CI, we've toggled on the integration, and we've specified that we want to send a webhook on a push event or a merge request event. You could also choose a tag push event as well. We specify the Jenkins URL, the project name, and a username or password and password or API token. And we see that it has been triggering successfully. The basic workflow here is to then create a branch and then create a merge request that is associated to that specific branch. We can go ahead and make some changes, and I've already done this once, but I'm going to do it again so we can actually see a pipeline execute. Make some changes to any files that we would need to change as part of our development activities. Commit those changes. Since I'm doing this within the web IDE, they're happening directly on the remote. We're not working from a local repo and then pushing. So this is going to trigger a pipeline, and we can see that that's triggered, and we can go back to the merge request and take a look at the details of the merge request. We can see now that a pipeline has been triggered and has reported as passing. If we go ahead and look at that pipeline, we can see that it's reporting one job, this external stage Jenkins job. And if we open that, click on that Jenkins job, it's going to bring us directly back into Jenkins so we can see all the details of what happened in order as part of this build process in Jenkins. So we can see that this, oh, my time zone is off. It's four hours off, but we can see that this was just triggered about 30 seconds ago, and we can even look at the console output if we want to. We can see here that it was triggered by a GitLab push, and, you know, we're not doing anything very exciting here. It started by GitLab push right there. Okay, so that's the freestyle job. That's really simple. Most people aren't using freestyle jobs in Jenkins. Some are. This would be a great way just to see what that build status is back in GitLab for those freestyle jobs. Let's take a look now at our pipeline jobs instead. And I should specify that this integration does not support multi-branch pipelines in Jenkins today. So if you are looking for something for multi-branch pipelines, there is a separate GitLab branch source plugin that's not maintained or owned by GitLab, but we know some customers are using that. You can take a look at that. But for us, we want to look at our Jenkins pipeline. So let's see how this one is configured to get the GitLab integration to work. So first of all, again, same kind of a thing to start with. Choose that we're going to integrate with a GitHub project, a GitLab project, in this case not GitHub, but that's just a label issue. Specify the URL, specify your GitLab connection that was set up under Manage Jenkins, and then build trigger based on when a change is pushed to GitLab. So same thing as a freestyle job so far. Now, since this is a pipeline, we want to specify what pipeline we're going to run. This is a Jenkins file. Now, in this case, we're storing the Jenkins file directly in our Jenkins server, which is a bad idea because it's hard to see what's changed if we change something. So version it under Git instead. But for the simplicity of the demo, we have it just stored here as a script. And we can see we're doing a couple of things here. We have two stages. First, a build stage, and it's going to first let GitLab know that the build is pending. Then it would execute whatever build steps should be executed, and it already does. In our case, we're just echoing, you know, build step goes here. But you would replace that with whatever build steps you have. Then once it completes successfully, you would report that build as a success. Or if you got a build failure returned, you would report to GitLab the build failed instead. For a test stage we have set up, we did a similar type of thing. But again, you would put all of your testing commands where echo test script test step goes here. But having a way to say that it's pending, you could even say that the state is running if you have some jobs that take a really long time to run. So it would be reflected back in GitLab that it's currently running and we're waiting for the success or failure. In my case, since these are simple, I just reflected pending and then success. And then that's all there is to the pipeline itself. Now, if you did want, for those of you who are newish to Jenkins or are trying to understand how this works, if you did want to store a Jenkins file in your Git repo, you would instead say pipeline script from SCM and point it to the root of your GitLab repository and it would find that Jenkins file for you. So once we have that configuration all set up, the integration on the GitLab side is exactly the same. So I have a different project here configured for our pipeline jobs and it's the same exact configuration on the GitLab side as the previous one I showed. So again, what we're going to do is we're going to create a branch and associate a merge request. And we're going to be able to then make changes for that merge request and see what happens when we commit and push those changes. Again, I'm going to just open up something really quick in web IDE to push changes fast. I'm very original in my changes, as you can see here. But the idea is just to show you what happens when those commits are pushed. So again, we're using merge request two in this project. We should see the pipeline status as it's running with Jenkins and it's checking on the pipeline status now. So it's doing something on the Jenkins side. And then here we see that the pipeline is already executed and passed successfully. In this case, we see two jobs, a build job and a test job. Now, we're going to build a test job. In this case, we see two jobs, a build job and a test job. Now, if for some reason the test failed, we would see a failure here. And when thinking about how this relates to our merge request, our merge request is where we want to have a source of truth about all the changes we've made, what impact they are having on our source code, whether or not they are able to be fully validated, tested appropriately. And then we can have code reviewers come in, review all of the changes, review the pipeline status and approve the merge request. So with that being said, there's also an option for each GitLab project to say, if your pipeline doesn't succeed, you won't be able to merge your changes to your protected branch, your master, whatever branch is protected. So that's going to be, again, another set of sanity check for you to make sure that everything is fully vetted, tested appropriately before being merged into the protected branch. If in this case, as we saw, there was a build and test job, if the test job failed for some reason, we would not be able to merge these changes into our protected branch with that project setting enabled. Okay, so this allows us to use a lot more of the functionality of GitLab than if we were just using version control and then having all of our pipeline statuses and some other tool completely disconnected from our Git repository. Okay, so that was a quick demo to show you how those two different types of jobs work with GitLab. There is one more thing that I wanted to talk about, and that is, what's the next step if you wanted to get even more sophisticated or if you wanted to start taking advantage of even more GitLab functionality while you're still figuring out how to migrate all of your Jenkins jobs over to GitLab? So in cases where you want to start using more of the GitLab functionality sooner, we do have some advanced options for you. First of all, you can use GitLab CI for your entire pipeline, and then using Jenkins APIs or wrappers around those APIs, you can pretty easily call an existing Jenkins job and report the results back to GitLab. That would allow you to use your existing Jenkins pipeline, but then also define some define some additional jobs that you want to run in GitLab. So if you wanted security scans, things such as SAS scanning and dependency management, license management, all of that you could use directly from the templates in GitLab, but have a build job first execute your Jenkins job. Or if you didn't even want to build until you ran a SAS job, for example, and that passed successfully, you could do vice versa. Order them in whatever order you want to and only move on based on past or failure of a particular stage. There's a great example that one of our technical marketing managers wrote in the blog that is posted here that will give you an example of how to write that kind of a pipeline using the Python wrapper for the Jenkins APIs. And it's nice and clean and simple. So you can go ahead and check that out. The other option we have is, and it's still an option in WIP, so I want to be very clear about that. So we're continuing to work on the creation of a Jenkins wrapper that would allow you to run a Jenkins file directly within GitLab CI. It would run the Jenkins file within a containerized Jenkins environment in a GitLab runner. So your entire Jenkins pipeline would essentially run as one job and report back values to failure or success. But again, it allows you to utilize the other GitLab functionality that's available, all of those templates that we have that you can use out of the box for the various types of security scanning and code quality jobs that we have. Keep in mind that this is still all in progress. It is in public testing today. You can take a look at the status of the current epoch where we're tracking our progress in this wrapper. And there might be some limitations in terms of what plugins you'll be able to use with the Jenkins wrapper and performance of the Jenkins build in the GitLab runner as well. But the advantage here is that not only will you get the build results reported back into GitLab, but you'll also get artifacts, your build artifacts, the ability to store those directly in GitLab as well. So these are both meant to be short-term solutions to help customers as they are migrating from Jenkins CI, CD to GitLab and to allow them to focus on migrating the jobs that are most impactful and that you're going to get the most bang for your buck in GitLab first and those really old jobs that you just need to keep around to run in Jenkins or that are just so complex that you just don't know where to get started with in order to figure out how to rewrite them to use GitLab CI. You keep those in Jenkins for now and worry about them later. So hopefully that gives you some options in terms of how to utilize GitLab and Jenkins together. And that's all I wanted to talk about today. Thank you.